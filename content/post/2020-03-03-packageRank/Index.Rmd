---
slug: packageRank-intro
title: "'packageRank': Introduction and Caveat"
authors:
  - lindbrook
date: 2020-03-01
tags:
- package development
output:
  html_document:
    keep_md: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "", comment = "")

knitr::knit_hooks$set(
  plot = function(x, options) {
    hugoopts <- options$hugoopts
    paste0(
      "{{<figure src=",
      '"', x, '" ',
      if (!is.null(hugoopts)) {
        glue::glue_collapse(
          glue::glue('{names(hugoopts)}="{hugoopts}"'),
          sep = " "
        )
      },
      ">}}\n"
    )
  }
)

library(packageRank)
library(ggplot2)
# knitr::opts_chunk$set(echo = TRUE)
```
'packageRank', [CRAN](https://cran.r-project.org/package=cholera) and [GitHub](https://www.github.com/lindbrook/packageRank), is an R package that helps you compute and visualize package download counts. It has two core functions: `cranDownloads()` and `packageRank()`.[^1] In this post, I'll do a brief overview of the package's features and of the systematic positive bias that affects download counts.

The package began as an effort to numerically and visually put a package's download counts into perspective: to see how well your package is really doing, you need to see how well (all) other packages are doing. One thing led to another in terms of features and functionality. But it was my hope of using this package to create an index of the state and health of R and its ecosystem(s) that led me to put this package on CRAN.

Note that throughout this blog plot post, I'll refer to _active_ and _inactive_ packages: the former are packages that are still being developed and that appear in the [CRAN repository](https://cran.r-project.org/web/packages/index.html); the latter are "retired" package that are stored in the [Archive](https://cran.r-project.org/src/contrib/Archive) along with past versions of active packages .

## I - `cranDownloads()`

`cranDownloads()` builds on `cranlogs::cran_downloads()`. It uses all the same arguments:

```{r cranDownloads}
cranlogs::cran_downloads(packages = "HistData")
cranDownloads(packages = "HistData")
```

But it adds four features:

### i) "spell check" for package names

```{r spell_check_fail, eval = FALSE}
cranDownloads(packages = "ggplot")
```
```
## Error in cranDownloads(packages = "ggplot") :
##   ggplot: misspelled or not on CRAN.
```

```{r spell_check_pass, eval = TRUE}
cranDownloads(packages = "ggplot2")
```

For inactive packages, this is optional because it currently requires scraping the CRAN website:

```{r check_archive_fail, eval = FALSE}
cranDownloads(packages = "vr", check.archive = TRUE)
```
```
## Error in cranDownloads(packages = "vr", check.archive = TRUE) :
##  vr: misspelled or not on CRAN/Archive.
```

```{r check_archive_pass}
cranDownloads(packages = "VR", check.archive = TRUE)
```

### ii) two addtional date formats

In addition to "yyyy-mm-dd", you can also use "yyyy-mm" or "yyyy" (yyyy works too!). This provides convenient and useful shortcuts.


##### "yyyy-mm"

Let's say you want the June 2019 download counts for 'HistData'. With `cranlogs::cran_downloads()`, you'd have to type out the whole date and remember that June has only 30 days:

```{r yyyy-mm_1, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2019-06-01", to = "2019-06-30")
```

With `cranDownloads()`, you can just specify the year and month:

```{r yyyy-mm_2, eval = FALSE}
cranDownloads(packages = "HistData", from = "2019-06", to = "2019-06")
```

"yyyy-mm" also automatically takes care of leap days:

```{r leap_day, eval = FALSE}
# The first will have 28 observations (rows); the second will have 29.
cranDownloads(packages = "HistData", from = "2019-02", to = "2019-02")
cranDownloads(packages = "HistData", from = "2020-02", to = "2020-02")
```

##### "yyyy"

Let's say you want the year-to-date download counts for 'rstan'. With `cranlogs::cran_downloads()`, you'd type:

```{r yyyy_1, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2020-01-01", to = Sys.Date() - 1)
```

With `cranDownloads()`, you can just type:

```{r yyyy_2, eval = FALSE}
cranDownloads(packages = "HistData", from = "2020")
```

### iii) check dates

`cranDownloads()` will also try to check for valid dates:

```{r check_date, eval = FALSE}
cranDownloads(packages = "HistData", from = "2019-01-15", to = "2019-01-35")
```
```
## Error in resolveDate(to, type = "to") : Not a valid date.
```

### iv) visualization

To visualize `cranDownloads()`, use `plot()`:

<!-- # ```{r cranDownloads_viz1, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 1 'HistData' Year-to-Date Downloads"} -->
```{r cranDownloads_viz1, hugoopts = list(caption = "Figure 1 'HistData' Year-to-Date Downloads", width = 400, height = 400)}
plot(cranDownloads(packages = "HistData", from = "2020"))
```

When you pass a vector of package names, the function will, by default, make use of `ggplot2` facets:

<!-- ```{r cranDownloads_viz2, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 2 Multiple Package Year-to-Date Downloads"} -->
```{r cranDownloads_viz2, hugoopts = list(caption = "Figure 2 Multiple Package Year-to-Date Downloads", width = 400, height = 400)}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"), from = "2020"))
```

## II - `packageRank()` and population plot

To see whether the patterns you see above are typical or atypical, 'packageRank' provides two ways to locate your package in the overall distribution of package downloads: `packageRank()` and a population plot.

### i) `packageRank()`

In contrast to `cranDownloads()`, `packageRank()` uses ranks and rank percentiles instead of counts.

The rank percentiles, a measure that will be familiar to anyone who's taken a standardized test like the SAT or GRE, is the percentage of packages that have fewer downloads than yours. For example, on January 1, 2020 'HistData''s 90 downloads put it in the 93rd percentile: 93% of packages had fewer than 90 downloads.

```{r packageRank, eval = FALSE}
packageRank(packages = "HistData", date = "2020-01-01")
```
```{r packageRank_code, eval = TRUE, echo = FALSE }
packageRank(packages = "HistData", date = "2020-01-01", size.filter = FALSE)
```

You can visualize the results using plot().

```{r packageRank_plot, eval = FALSE}
plot(packageRank(packages = "HistData", date = "2020-01-01"))
```
<!-- ```{r packageRank_plot_code, fig.width = 5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 3 'HistData' Position in the Distribution of Package Downloads, 01 January 2020"} -->
```{r packageRank_plot_code, hugoopts = list(caption = "Figure 3 'HistData' Position in the Distribution of Package Downloads, 01 January 2020", width = 400, height = 400)}
plot(packageRank(packages = "HistData", date = "2020-01-01", size.filter = FALSE))
```

The graph plots the rank of the download count for _all_ packages downloaded that day (x-axis) against the natural log of those counts (y-axis). It then highlights your package's position in that distribution along with its rank percentile and download count (in red). In the background, you'll see the location of the 75th, 50th and 25th percentiles (dotted gray vertical lines); the package with the most downloads, 'magrittr' (in blue, top left); and the total number of downloads (2,254,532) (in blue, top right).

### ii) population plot

The population plot provides a way to visually estimate the overall distribution of CRAN package downloads. It does so by fitting lowess curves to the download counts of a stratified random sample of packages.[^2] You simply set the `population.plot` argument to TRUE:[^3]

<!-- ```{r pop_plot, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 4 'HistData' Population Plot"} -->
```{r pop_plot, hugoopts = list(caption = "this is what this image shows, write it here or in the paragraph after the image as you prefer", width = 400, height = 400)}
plot(cranDownloads(packages = "HistData", when = "last-month"), population.plot = TRUE)
```

## III - caveat: positive bias in download counts

A systematic positive bias affects package download counts. This bias manifests itself as two types of "invalid" downloads: 1) downloads that are "too small"; and 2) an overrepresentation of past versions. These "invalid" downloads undermine the strategy of counting package downloads by counting the number of entries in the download logs.

What makes these downloads especially problematic is that, as part of efforts to mirror or download CRAN in its entirety, they are particularly numerous on Wednesdays (and additional days). Depending on what you're trying to do, this could affect your analyses and inferences. Fortunately, I think we can minimize their effect by cleaning the data by filtering out "small" downloads and by filtering out or discounting past versions.

To understand this bias, you should look at actual download logs. RStudio's logs are available [here](http://cran-logs.rstudio.com/). You can also access them using `packageRank::packageLog()`. Below is the log for 'cholera' for February 2, 2020:

```{r log, eval = FALSE}
packageLog(package = "cholera", date = "2020-02-02")
```
```{r log_code, echo = FALSE, eval = TRUE}
log <- packageLog("cholera", "2020-02-02")
log[, !names(log) %in% c("r_version","r_arch", "r_os")]
```

### i) "small" downloads

Entries 5 through 7 of that log illustrate the "small" downloads problem:

```{r log_small, eval = FALSE, echo = FALSE}
packageLog("cholera", "2020-02-02")[5:7, ]
```
```{r log_small_code, echo = FALSE}
log <- packageLog("cholera", "2020-02-02")
log[5:7, !names(log) %in% c("r_version","r_arch", "r_os")]
```

Notice the differences in size: 4.1 MB, 35 kB and 539 B. On CRAN, the source and binary files of 'cholera' are either a [4.0 or a 4.1 MB \*.tar.gz file](https://cran.r-project.org/src/contrib/Archive/cholera/). In short, the problem with "small" downloads is that we end up overcounting the number of actual downloads.

While I'm unsure about the kB-sized entry (it may be a side effect of caching or an incomplete download), my current understanding is that ~500 B downloads represent [HTTP HEAD requests from lftp](https://github.com/r-hub/cranlogs/issues/45). The earliest example I've found goes back to "2012-10-17" (Note that RStudio's download logs only go back to "2012-10-01".). While these "small" downloads aren't always paired with "complete" downloads, their frequency is such that I wonder whether `lftp` or something similar is/was part of the R and/or RStudio.

To get a sense of their frequency, I look back to October 2019. In aggregate, ~500 B downloads account for approximately 2% of the total. While this seems modest (if 2.5 million downloads could be modest), I'd argue that there's actually something lurking underneath: a closer look reveals that the difference between the total and filtered (without ~500 B entries) is greatest on the five Wednesdays.

<!-- ```{r counts_plot, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 5 Total CRAN Downloads With and Without ~500 B Entries"} -->
```{r counts_plot, hugoopts = list(alt = "alternative text please make it informative", title = "title of the image", caption = "Figure 5 Total CRAN Downloads With and Without ~500 B Entries", width = 520, height = 400), echo = FALSE}
pt1 <- paste0("0", 1:9)
oct.root <- "2019-10-"
oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

dl.ct <- blog.data$dl.ct
dl.ct2 <- blog.data$dl.ct2

plot(oct, dl.ct, type = "o", col = "red", pch = 15,
  ylim = range(dl.ct, dl.ct2), xlab = "Date", ylab = "Count")
lines(oct, dl.ct2, type = "o", col = "black", pch = 16)
abline(v = oct[id], col = "gray", lty = "dotted")
axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
  col.ticks = "black")
title(main = "Download Counts (Log Entries)")
legend(x = "bottomleft",
       legend = c("all", "filtered"),
       col = c("red", "black"),
       pch = c(15, 16),
       bg = "white",
       cex = 2/3,
       lwd = 1,
       title = NULL)
```

To see what's going on, I switch the unit of observation from download counts to the number of unique packages downloaded:

<!-- ```{r packages_plot, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 6 Total Number of Unique Packages Downloaded from CRAN With and Without ~500 B Entries"} -->
```{r packages_plot, hugoopts = list(caption = "Figure 6 Total Number of Unique Packages Downloaded from CRAN With and Without ~500 B Entries", width = 520, height = 400), echo = FALSE}
pt1 <- paste0("0", 1:9)
oct.root <- "2019-10-"
oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

pkg.ct <- blog.data$pkg.ct
pkg.ct2 <- blog.data$pkg.ct2

plot(oct, pkg.ct, type = "o", col = "red", pch = 15,
  ylim = range(pkg.ct, pkg.ct2), xlab = "Date", ylab = "Count")
lines(oct, pkg.ct2, type = "o", col = "black", pch = 16, lwd = 2)
abline(v = oct[id], col = "gray", lty = "dotted")
axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
  col.ticks = "black")
title(main = "Packages Downloaded")
legend(x = "bottomleft",
       legend = c("all", "filtered"),
       col = c("red", "black"),
       pch = c(15, 16),
       bg = "white",
       cex = 2/3,
       lwd = 1,
       title = NULL)
```

Doing so, we see that on Wednesdays (+3 days) the total number of unique packages downloaded tops 17,000. This is significant because it exceeds the 15,000+ active packages on CRAN (see the latest count [here](https://cran.r-project.org/web/packages/index.html)). The only way to hit 17,000+ would be to include some, if not all, of the 2,000+ inactive packages. Based on this, I'd say that on those peak days virtually, if not literally, all active and inactive packages on CRAN were downloaded.[^4]

### ii) past versions

This actually understates what's going on. It's not just that "all" packages are being downloaded but that "all" versions of "all" packages are being downloaded. This is what leads me to argue that there's an overrepresentation of past versions. Here, I'm not referring to downloads done for compatibility or research, which one would think would be random and infrequent. Instead, I'm talking about seeing regular and repeated patterns like this:

```{r log_versions, eval = FALSE}
packageLog(packages = "cholera", date = "2019-10-22")[1:8, ]
```
```{r log_full_downloads_code, echo = FALSE}
log <- packageLog("cholera", "2019-10-22")
log[1:8, !names(log) %in% c("r_version","r_arch", "r_os")]
```

On this day, eight versions of 'cholera' were downloaded. A little digging with `packageRank::packageHistory()` will reveal that these eight versions represent all the versions that were available that day:

```{r packageHistory}
packageHistory("cholera")
```

Showing that "all" versions are being downloaded is not as easy as showing the effect of "small" downloads. To do so, you'd need to the version history of all packages. This is currently a computationally expensive task.[^5] For this post, I'm relying on a random sample of 100 active and 100 inactive packages.

The graph below plots the percent of versions downloaded for each day in October 2019 (IDs 1-100 are _active_ packages; IDs 101-200 are inactive _packages_). On the five Wednesdays (+ 3 additional days), there's a horizontal line at 100% that indicates that all versions of the packages in the sample were downloaded.[^6]

<!-- ```{r versions_plot, fig.align = "center", echo = FALSE, fig.cap = "Figure 7 Percent of Versions Downloaded for 100 Active & 100 Inactive Packages"} -->
```{r versions_plot, hugoopts = list(caption = "Figure 7 Percent of Versions Downloaded for 100 Active & 100 Inactive Packages", width = 520, height = 400), echo = FALSE}

cran.pkg_ver <- blog.data$cran.pkg_ver
for (i in seq_along(cran.pkg_ver)) {
  cran.pkg_ver[[i]]$pkg.id <- seq_len(nrow(cran.pkg_ver[[i]]))
}
pkg.dataA <- do.call(rbind, cran.pkg_ver)

archive.pkg_ver <- blog.data$archive.pkg_ver
for (i in seq_along(archive.pkg_ver)) {
  archive.pkg_ver[[i]]$pkg.id <- 100:199
}
pkg.dataB <- do.call(rbind, archive.pkg_ver)

pkg.data <- rbind(pkg.dataA, pkg.dataB)
pkg.data$pct.obs.exp <- 100 * pkg.data$pct.obs.exp

ggplot(data = pkg.data, aes(x = pkg.id, y = pct.obs.exp)) +
  geom_line(col = adjustcolor("red", alpha.f = 0.5), size = 0.5) +
  geom_vline(xintercept = 99.5, col = "black", linetype = "dashed") +
  xlab("Package ID") +
  ylab("Percent") +
  facet_wrap(~ date, ncol = 7) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ggtitle("Percent of Package-Versions Downloaded: Active & Inactive Packages")
```

### iii) solutions

To minimize this bias we could filter out "small" downloads and past versions. Filtering out 500 B downloads is simple and straightforward (`packageRank()` and `packageLog()` already include this functionality). My understanding is that there may be plans to do this in 'cranlogs' as well. Filtering out other "small" downloads is more involved but not impossible. You just need the size of "valid" downloads. Filtering out "past" versions is more complicated since you not only need to know which version is current, you probably also want a way to discount rather than simply exclude previous version(s).

Whether you should worry about this depends on what you're trying to do. It also depend on the package you're interested in. This is because the bias is variable, a function of a package's "popularity" (i.e, its number of "valid" downloads) and the number of versions of package has. A package with more "real" downloads will be less affected than one with fewer "real" downloads because the bias gets diluted (typically "real" interest is greater than "artificial" interest). A package with more versions will be more affected because as CRAN in its entirety is being downloaded, a package with more versions will record more downloads than one with fewer versions.

#### popularity
```{r pkgPlot, echo = FALSE}
pkgPlot <- function(package = "cholera", filter = "size",
  legend.loc = "topleft") {

  if (!filter %in% c("size", "version", "size.version")) {
    stop('Filter must be "size", "version", or "size.version".')
  }

  pt1 <- paste0("0", 1:9)
  oct.root <- "2019-10-"
  oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
  id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

  dat <- blog.data[[paste0(package, ".data")]]

  plot(oct, dat$ct, type = "o", col = "red", pch = 15,
    ylim = range(dat[, 1:4]), xlab = "Date", ylab = "Count")
  filter.id <- paste0("ct.", tolower(filter))
  lines(oct, dat[, filter.id], type = "o", col = "black", pch = 16)
  lines(lowess(oct, dat$ct), lty = "dotted", col = "red")
  lines(lowess(oct, dat[, filter.id]), lty = "dotted")
  abline(v = oct[id], col = "gray", lty = "dotted")
  axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
    col.ticks = "black")

  if (filter == "size") {
    title(main = paste0(package, ": Size"))
    sel <- "ct.size"
  } else if (filter == "version") {
    title(main = paste0(package, ": Version"))
    sel <- "ct.version"
  } else if (filter == "size.version") {
    title(main = paste0(package, ": Size & Version"))
    sel <- "ct.size.version"
  }

  tot <- colSums(dat)
  ptA <- paste0("Downloads: all = ", format(tot["ct"], big.mark = ","),
    "; filtered = ")
  ptB <- paste0("% | ", unique(dat$version.ct), " versions")
  
  delta.pct <- round(100 * (tot["ct"] - tot[sel]) / tot[sel], 1)
  title(sub = paste0(ptA, format(tot[sel], big.mark = ","), "; %âˆ† = ",
    format(delta.pct, big.mark = ","), ptB))
  legend(x = legend.loc,
         legend = c("all", "filtered"),
         col = c("red", "black"),
         pch = c(15, 16),
         bg = "white",
         cex = 2/3,
         lwd = 1,
         title = NULL)
}
```
To illustrate the effect of popularity, I compare 'ggplot2' and 'cholera'. With one million plus downloads, 500 B entries inflate the download count for 'ggplot2' by 2%:

<!-- ```{r ggplot2, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 8 Effect of ~500 B Downloads on Download Counts for a Popular Package"} -->
```{r ggplot2, hugoopts = list(caption = "Figure 8 Effect of ~500 B Downloads on Download Counts for a Popular Package", width = 520, height = 400), echo = FALSE}
pkgPlot("ggplot2")
```

With under 400 downloads, 500 B entries inflate the download count for 'cholera' by 25%:

<!-- ```{r cholera, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 9 Effect of ~500 B Downloads on Download Counts for an Unpopular Package"} -->
```{r cholera, hugoopts = list(caption = "Figure 9 Effect of ~500 B Downloads on Download Counts for an Unpopular Package", width = 520, height = 400), echo = FALSE}
pkgPlot()
```

#### number of versions

To illustrate the effect of the number of versions, I compare 'cholera', an active package with 8 versions, and 'VR', an inactive package last updated in 2009 with 92 versions. In both cases, I filter out all downloads except for those the most recent version.

With 'cholera', the past version inflate the download count by 27%:

<!-- ```{r cholera_version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 10 Effect of the Number of Past Versions on Download Counts for a Package with Few Versions"} -->
```{r cholera_version, hugoopts = list(caption = "Figure 10 Effect of the Number of Past Versions on Download Counts for a Package with Few Versions", width = 520, height = 400), echo = FALSE}
pkgPlot(filter = "version")
```

For 'VR', past version inflated the download count by 7,500%:

<!-- ```{r vr_version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 11 Effect of the Number of Past Versions on Download Counts for a Package with Many Versions"} -->
```{r vr_version, hugoopts = list(caption = "Figure 11 Effect of the Number of Past Versions on Download Counts for a Package with Many Versions", width = 520, height = 400), echo = FALSE}
pkgPlot("VR", filter = "version")
```

#### popularity & versions

To illustrate the joint effect of both ~500 B downloads and previous versions, I use 'cholera'. Here, we see that the joint effect of both biases inflate the download count by 31%:

<!-- ```{r cholera_size.version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 12 Effect of ~500 B Downloads and Number of Past Versions on Download Counts"} -->
```{r cholera_size.version, hugoopts = list(caption = "Figure 12 Effect of ~500 B Downloads and Number of Past Versions on Download Counts", width = 520, height = 400), echo = FALSE}
pkgPlot(filter = "size.version")
```

Even though the bias is pretty mechanical and deterministic, to show that examples above are not idiosyncratic, I conclude with a back-of-the-envelope estimate of the effect of popularity (unfiltered downloads) and version count (total number of versions) on total bias (the percent change in download counts after filtering out ~500 B download and prior versions). The sample of 200 active and inactive packages used above is my data. I fit a linear model using the natural log of the three variables. The hope is that signs are right: bias is negatively related to popularity and positively related to the number of versions.

```{r ols, echo = FALSE}
oct.data <- blog.data$oct.data
smpl <- blog.data$smpl
smpl.histories <- blog.data$smpl.histories
smpl.archive <- blog.data$smpl.archive
smpl.archive.histories <- blog.data$smpl.archive.histories

sample.pkgs <- c(smpl, smpl.archive)
sample.pkgs <- sample.pkgs[sample.pkgs != "hardhat"]

vars <- c("count", "size", "version", "size.version")

p.data <- do.call(rbind, oct.data)
p.data <- lapply(sample.pkgs, function(pkg) {
  colSums(p.data[p.data$package == pkg, vars])
})

histories <- c(smpl.histories[names(smpl.histories) != "hardhat"],
  smpl.archive.histories)

v.ct <- vapply(histories, nrow, integer(1L))

p.data <- data.frame(package = sample.pkgs, do.call(rbind, p.data),
  ver.ct = v.ct, stringsAsFactors = FALSE)

row.names(p.data) <- NULL

p.data$size.bias <- 100 * (p.data$count - p.data$size) / p.data$size
p.data$version.bias <- 100 * (p.data$count - p.data$version) / p.data$version
p.data$size.version.bias <- 100 * (p.data$count - p.data$size.version) /
  p.data$size.version

# p.data$popularity <- p.data$count
p.data$popularity <- p.data$size.version
p.data$versions <- p.data$ver.ct
p.data$bias <- p.data$size.version.bias

ols1 <- lm(log(bias) ~ log(popularity) + log(versions), data = p.data)
ols2 <- lm(log(bias) ~ log(popularity) + log(versions) + 
  log(popularity) * log(versions), data = p.data)

# car::avPlots(ols1, layout = c(1, 1), grid = FALSE)
# car::avPlots(ols2, layout = c(1, 1), grid = FALSE)
```

```{r ols_summary, echo = FALSE}
summary(ols2)
```

## Notes

[^1]: Similar but limited functionality is available for Bioconductor packages using `bioconductorDownloads()` and `bioconductorRank()`.
[^2]: I take a random sample of 5% of the packages within each of the twenty 5 percentile bins between between 0 and 1: between 0 and 0.05, 0.05 and 0.10, etc.
[^3]: Because this is computationally intensive, this is only available for `when = "last-week"` or `when = "last-month"`.
[^4]: The slight upward trend in the peaks probably reflects the addition of new packages during the month.
[^5]: `packageHistory()` currently scrapes the CRAN website.
[^6]: On 22 October 2019, there are two exceptions among inactive packages, 'UScensus2000blkgrp' and 'msDilution', which had zero downloads.
