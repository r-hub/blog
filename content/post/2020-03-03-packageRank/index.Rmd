---
slug: packageRank-intro
title: "'packageRank': Introduction and Caveat"
authors:
  - lindbrook
date: 2020-03-01
tags:
- package development
output:
  html_document:
    keep_md: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "", comment = "")

knitr::knit_hooks$set(
  plot = function(x, options) {
    hugoopts <- options$hugoopts
    paste0(
      "{{<figure src=",
      '"', x, '" ',
      if (!is.null(hugoopts)) {
        glue::glue_collapse(
          glue::glue('{names(hugoopts)}="{hugoopts}"'),
          sep = " "
        )
      },
      ">}}\n"
    )
  }
)

library(packageRank)
library(ggplot2)
# knitr::opts_chunk$set(echo = TRUE)
```
> This post was contributed by [Peter Li](https://www.github.com/lindbrook/). Thank you, Peter!

[`'packageRank'`](https://cran.r-project.org/package=packageRank) is an R package that helps put package download counts into context. It does so via two functions, `cranDownloads()` and `packageRank()`.[^1] `cranDownloads()` extends [`cranlogs::cran_downloads()`](http://r-hub.github.io/cranlogs/) package by adding a `plot()` method and a more user-friendly interface to the task of counting package downloads. `packageRank()` uses rank percentiles, a nonparametric statistic that tells you the percentage of packages with fewer downloads, to help you see how your package is doing compared to all other packages on [CRAN](https://cran.r-project.org/).

In this post, I'll do an overview of the package's features and functions. Then, I'll discuss the systematic positive bias that affects download counts. Finally, I'll conclude by discussing future directions and efforts.

Note that in this post, I'll refer to _active_ and _inactive_ packages: the former are packages that are still being developed and appear in the [CRAN repository](https://cran.r-project.org/web/packages/index.html); the latter are "retired" packages that are stored in the [Archive](https://cran.r-project.org/src/contrib/Archive) along with past versions of active packages.

******

# `cranDownloads()`

`cranDownloads()` uses all the same arguments as `cranlogs::cran_downloads()`:

```{r cran_downloads}
cranlogs::cran_downloads(packages = "HistData")
```

<br/>

```{r cranDownloads}
cranDownloads(packages = "HistData")
```

<br/>
The only difference is that `cranDownloads()` adds four features:


### "spell check" for package names

```{r spell_check_fail, eval = FALSE}
cranDownloads(packages = "GGplot2")
```
```
## Error in cranDownloads(packages = "GGplot2") :
##   GGplot2: misspelled or not on CRAN.
```

<br/>
```{r spell_check_pass, eval = TRUE}
cranDownloads(packages = "ggplot2")
```

<br/>
This will also work for inactive packages in the [Archive](https://cran.r-project.org/src/contrib/Archive):
<br/>

```{r check_archive_fail, eval = FALSE}
cranDownloads(packages = "vr")
```
```
## Error in cranDownloads(packages = "vr") :
##  vr: misspelled or not on CRAN/Archive.
```

<br/>
```{r check_archive_pass}
cranDownloads(packages = "VR")
```

<br/>

### two additional date formats

In addition to "yyyy-mm-dd", you can also use "yyyy-mm" or "yyyy" (yyyy works too!). This provides convenient and useful shortcuts.

#### "yyyy-mm"

Let's say you want the June 2019 download counts for [`'HistData'`](https://cran.r-project.org/package=HistData). With `cranlogs::cran_downloads()`, you'd have to type out the whole date and remember that June has only 30 days:

```{r yyyy-mm_1, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2019-06-01", to = "2019-06-30")
```

<br/>
With `cranDownloads()`, you can just specify the year and month:

```{r yyyy-mm_2, eval = FALSE}
cranDownloads(packages = "HistData", from = "2019-06", to = "2019-06")
```

<br/>
Note that "yyyy-mm" will also take care of leap days:

```{r leap_day, eval = FALSE}
# 28 observations
cranDownloads(packages = "cholera", from = "2019-02", to = "2019-02")

# 29 observations
cranDownloads(packages = "cholera", from = "2020-02", to = "2020-02")
```

<br/>

#### "yyyy"

Let's say you want the year-to-date download counts for [`'rstan'`](https://cran.r-project.org/package=rstan). With `cranlogs::cran_downloads()`, you'd type something like:

```{r yyyy_1, eval = FALSE}
cranlogs::cran_downloads(packages = "HistData", from = "2020-01-01", to = Sys.Date() - 1)
```

<br/>
With `cranDownloads()`, you can just type:

```{r yyyy_2, eval = FALSE}
cranDownloads(packages = "HistData", from = "2020")
```

<br/>

### check dates

`cranDownloads()` also tries to check for valid dates:

```{r check_date, eval = FALSE}
cranDownloads(packages = "HistData", from = "2019-01-15", to = "2019-01-35")
```
```
## Error in resolveDate(to, type = "to") : Not a valid date.
```

<br/>

### visualization

To visualize `cranDownloads()`, use `plot()`:

<!-- ```{r cranDownloads_viz1, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 1 'HistData' Year-to-Date Downloads"} -->
```{r cranDownloads_viz1, fig.align = "center", hugoopts = list(caption = "Figure 1 'HistData' Year-to-Date Downloads")}
plot(cranDownloads(packages = "HistData", from = "2020"))
```

<br/>
When you pass a vector of package names, the function defaults to the use of `ggplot2` facets:

<!-- ```{r cranDownloads_viz2, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 2 Multiple Package Year-to-Date Downloads"} -->
```{r cranDownloads_viz2, fig.align = "center", hugoopts = list(caption = "Figure 2 Multiple Package Year-to-Date Downloads")}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"), from = "2020"))
```

<br/>
If you want to plot all the data in a single plot, set `multi.plot = TRUE`:

<!-- ```{r cranDownloads_viz3, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure X Multiple Package Year-to-Date Downloads"} -->
```{r cranDownloads_viz3, eval = FALSE}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"), from = "2020"), multi.plot = TRUE)
```

<br/>
If you want to plot the data in separate plots, each on its own scale, set `graphics = "base"`:

<!-- ```{r cranDownloads_viz4, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure X Multiple Package Year-to-Date Downloads"} -->
```{r cranDownloads_viz4, eval = FALSE}
plot(cranDownloads(packages = c("ggplot2", "data.table", "Rcpp"), from = "2020"), graphics = "base")
```

******

# `packageRank()`

'packageRank' began as a collection of functions I wrote to gauge interest in the [`'cholera'`](https://cran.r-project.org/package=cholera) package.

However, after looking at the data for 'cholera' and other packages, the "compared to what?" question quickly came to mind. For instance, consider this example for the first week of March 2020:

<!-- ```{r motivation, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 3 'cholera' March 1 - 7, 2020"} -->

```{r motivation, eval = FALSE}
plot(cranDownloads(packages = "cholera", from = "2020-03-01", to = "2020-03-07"))
```

```{r motivation_code, echo = FALSE, fig.align = "center", hugoopts = list(caption = "Figure 3 'cholera' March 1-7, 2020")}
par(mar = c(5, 4, 4, 4))
plot(cranDownloads(packages = "cholera", from = "2020-03-01", to = "2020-03-07"))
par(mar = c(5, 4, 4, 2))
```

Do the peaks on Wednesday and Saturday represent surges of interest in the package or surges of traffic to [CRAN](https://cran.r-project.org/)? To put it more broadly, how can we know if a given download count is typical or unusual?

One way to answer these questions is to locate the package in the frequency distribution of download counts. Unfortunately, this distribution is typically exponential and heavily skewed. Below are the distributions for Wednesday and Saturday:

<!-- ```{r skew, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 4 'cholera' Skewed Frequency Distribution"} -->

```{r skew_wed, fig.align = "center", hugoopts = list(caption = "Figure 4 'cholera' Frequency Distribution Wednesday"), echo = FALSE}
# ```{r skew, echo = FALSE, fig.show = "hold", out.width = "50%"}
x <- packageDistribution("cholera", c("2020-03-04", "2020-03-07"))
freq.dist1 <- x[[1]]$freq.dist
freq.dist2 <- x[[2]]$freq.dist
xlim <- range(freq.dist1$count, freq.dist2$count)
ylim <- range(freq.dist1$frequency, freq.dist2$frequency)

crosstab <- x[[1]]$crosstab
plot(freq.dist1$count, freq.dist1$frequency, xlab = "Downloads",
  ylab = "Frequency", xlim = xlim, ylim = ylim)
pkg.ct <- crosstab[names(crosstab) == x[[1]]$package]
pkg.bin <- crosstab[crosstab == pkg.ct]
# points(pkg.ct, length(pkg.bin) - which(names(pkg.bin) == x[[1]]$package),
#   col = "red", pch = 16)
axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
  cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
day <- weekdays(as.Date(x[[1]]$date), abbreviate = TRUE)
title(paste0(x[[1]]$package, " @ ", x[[1]]$date, " (", day, ")"))
```

```{r skew_sat, fig.align = "center", hugoopts = list(caption = "Figure 5 'cholera' Frequency Distribution Saturday"), echo = FALSE}

crosstab <- x[[2]]$crosstab
plot(freq.dist2$count, freq.dist2$frequency, xlab = "Downloads",
  ylab = "Frequency", xlim = xlim, ylim = ylim)
pkg.ct <- crosstab[names(crosstab) == x[[2]]$package]
pkg.bin <- crosstab[crosstab == pkg.ct]
# points(pkg.ct, length(pkg.bin) - which(names(pkg.bin) == x[[2]]$package),
#   col = "red", pch = 16)
axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
  cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
day <- weekdays(as.Date(x[[2]]$date), abbreviate = TRUE)
title(paste0(x[[2]]$package, " @ ", x[[2]]$date, " (", day, ")"))
```

The left side of the distribution, where packages with fewer downloads are located, _looks_ like a vertical line. This is because, using Wednesday as an example, the most downloaded package had 177,745 downloads while the least downloaded package had just 1. To help see what's going on, I redraw the plots using the logarithm of download counts (x-axis).

In these plots, each vertical segment represents an observed download count and the height of a segment represents the number of packages with that download count:

<!-- ```{r packageDistribution, fig.width = 5, fig.height = 5, fig.align = "center", fig.cap = "Figure 5 'cholera' Frequency Distribution Log(Downloads)"}
# ```{r packageDistribution, fig.show = "hold", out.width = "50%", echo = FALSE} -->

```{r packageDistribution, echo = FALSE}
plot_package_distribution <- function(dat, xlim, ylim) {
  freq.dist <- dat$freq.dist
  crosstab <- dat$crosstab

  plot(freq.dist$count, freq.dist$frequency, type = "h", log = "x",
    xlab = "Downloads", ylab = "Frequency", xlim = xlim, ylim = ylim)
  axis(3, at = crosstab[1], cex.axis = 0.8, padj = 0.9, col.axis = "dodgerblue",
    col.ticks = "dodgerblue", labels = paste(names(crosstab[1]), "=",
    format(crosstab[1], big.mark = ",")))
  abline(v = crosstab[1], col = "dodgerblue", lty = "dotted")

  if (!is.null(dat$package)) {
    pkg.ct <- crosstab[names(crosstab) == dat$package]
    pkg.bin <- crosstab[crosstab == pkg.ct]
    axis(3, at = pkg.ct, labels = format(pkg.ct, big.mark = ","),
      cex.axis = 0.8, padj = 0.9, col.axis = "red", col.ticks = "red")
    abline(v = pkg.ct, col = grDevices::adjustcolor("red", alpha.f = 0.5))
    day <- weekdays(as.Date(dat$date), abbreviate = TRUE)
    title(paste0(dat$package, " @ ", dat$date, " (", day, ")"))
  } else title(paste("Distribution of Package Download Counts:", dat$date))
}

distn.data <- packageDistribution(package = "cholera", date = c("2020-03-04",
  "2020-03-07"))

xlim <- range(lapply(distn.data, function(x) x$freq.dist$count))
ylim <- range(lapply(distn.data, function(x) x$freq.dist$frequency))
```

```{r packageDistribution_wed, eval = FALSE}
plot(packageDistribution(package = "cholera", date = "2020-03-04"))
```
```{r packageDistribution_wed_code, fig.align = "center", hugoopts = list(caption = "Figure 6 'cholera' Frequency Distribution with Log(Downloads): Wednesday")}
plot_package_distribution(distn.data[[1]], xlim, ylim)
```

```{r packageDistribution_sat, eval = FALSE}
plot(packageDistribution(package = "cholera", date = "2020-03-07"))
```
```{r packageDistribution_sat_code, fig.align = "center", hugoopts = list(caption = "Figure 7 'cholera' Frequency Distribution with Log(Downloads): Saturday")}
plot_package_distribution(distn.data[[2]], xlim, ylim)
```

While these plots give us a better picture of where 'cholera' is located on those days, any comparison between Wednesday and Saturday is impressionistic at best: all we can confidently say is that the download counts for both days were above than the mode.

To address this, I compute the _rank percentile_ of download counts. This nonparametric statistic tells us the percentage of packages with fewer downloads. By standardizing or normalizing the data, we get an easy-to-interpret measure that provides a way to compare Wednesday and Saturday.

```{r packageRank1}
packageRank(package = "cholera", date = "2020-03-04", size.filter = FALSE)
```

<br/>

```{r packageRank2}
packageRank(package = "cholera", date = "2020-03-07", size.filter = FALSE)
```

On Wednesday, 'cholera' had 38 downloads and came in 5,556th place out of 18,038 unique packages downloaded. This earned 'cholera' a spot in the 68th percentile. On Saturday, 'cholera' had 29 downloads and came in 3,061st place out of 15,950 unique packages downloaded. This earned 'cholera' a spot in the 80th percentile. So contrary to what the nominal download counts tell us, one could argue that there was greater interest in 'cholera' on Saturday than on Wednesday.

<br/>

### computing rank percentiles

To compute the rank percentile, I do the following. For each package I tabulate the number of downloads and then compute the percentage of packages with fewer downloads. Here are the details using 'cholera' from that Wednesday:

```{r percentile}
pkg.rank <- packageRank(packages = "cholera", date = "2020-03-04", size.filter = FALSE)
downloads <- pkg.rank$crosstab

round(100 * mean(downloads < downloads["cholera"]), 1)

# OR

(pkgs.with.fewer.downloads <- sum(downloads < downloads["cholera"]))

(tot.pkgs <- length(downloads))

round(100 * pkgs.with.fewer.downloads / tot.pkgs, 1)
```

<br/>

### visualizing rank percentiles

To visualize `packageRank()`, use `plot()`.



```{r packageRank_plot_wed, eval = FALSE}
plot(packageRank(packages = "cholera", date = "2020-03-04"))
```


```{r packageRank_plot_sat, eval = FALSE}
plot(packageRank(packages = "cholera", date = "2020-03-07"))
```


<!-- ```{r packageRank_plot_code, fig.width = 5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 6 'HistData' Position in the Distribution of Package Downloads, March 3 & 7, 2020"} -->

```{r packageRank_data, echo = FALSE}
dat <- lapply(c("2020-03-04", "2020-03-07"), function(x) {
  packageRank("cholera", date = x, size.filter = FALSE)
})

crosstab1 <- dat[[1]]$crosstab
crosstab2 <- dat[[2]]$crosstab
xlim <- range(seq_along(crosstab1), seq_along(crosstab2))
ylim <- range(c(crosstab1), c(crosstab2))
```

```{r packageRank_plot_code_wed, echo = FALSE, fig.align = "center", hugoopts = list(caption = "Figure 8 'cholera' and the Distribution of Package Downloads, March 4, 2020")}

crosstab <- dat[[1]]$crosstab
package.data <- dat[[1]]$package.data
pkg <- dat[[1]]$packages
date <- dat[[1]]$date
y.max <- crosstab[1]
q <- stats::quantile(crosstab)[2:4]

iqr <- vapply(c("75%", "50%", "25%"), function(id) {
  dat <- which(crosstab > q[[id]])
  dat[length(dat)]
}, numeric(1L))

plot(seq_along(crosstab), c(crosstab), type = "l", xlab = "Rank",
  ylab = "log10(Count)", log = "y", xlim = xlim, ylim = ylim)
abline(v = iqr, col = "black", lty = "dotted")
iqr.labels <- c("75th", "50th", "25th")
abline(v = which(names(crosstab) == pkg), col = "red")
abline(h = crosstab[pkg], col = "red")
pct <- package.data[package.data$package == pkg, "percentile"]
pct.label <- paste0(round(pct, 2), "%")
axis(3, at = which(names(crosstab) == pkg), padj = 0.9, col.axis = "red",
  col.ticks = "red", labels = pct.label, cex.axis = 0.8)
axis(4, at = crosstab[pkg], col.axis = "red", col.ticks = "red",
  cex.axis = 0.8, labels = format(crosstab[pkg], big.mark = ","))
points(which(names(crosstab) == pkg), crosstab[pkg], col = "red")
points(which(names(crosstab) == names(crosstab[1])), y.max,
  col = "dodgerblue")
text(which(names(crosstab) == names(crosstab[1])), y.max, pos = 4,
  labels = paste(names(crosstab[1]), "=", format(crosstab[1],
  big.mark = ",")), cex = 0.8, col = "dodgerblue")
text(max(xlim), max(ylim),
  labels = paste("Tot = ", format(sum(crosstab), big.mark = ",")), cex = 0.8,
  col = "dodgerblue", pos = 2)
title(main = paste(pkg, "@", date))
````

```{r packageRank_plot_code_sat, echo = FALSE, fig.align = "center", hugoopts = list(caption = "Figure 9 'cholera' and the Distribution of Package Downloads, March 7, 2020")}
crosstab <- dat[[2]]$crosstab
package.data <- dat[[2]]$package.data
pkg <- dat[[2]]$packages
date <- dat[[2]]$date
y.max <- crosstab[1]
q <- stats::quantile(crosstab)[2:4]

iqr <- vapply(c("75%", "50%", "25%"), function(id) {
  dat <- which(crosstab > q[[id]])
  dat[length(dat)]
}, numeric(1L))

plot(seq_along(crosstab), c(crosstab), type = "l", xlab = "Rank",
  ylab = "log10(Count)", log = "y", xlim = xlim, ylim = ylim)
abline(v = iqr, col = "black", lty = "dotted")
iqr.labels <- c("75th", "50th", "25th")
abline(v = which(names(crosstab) == pkg), col = "red")
abline(h = crosstab[pkg], col = "red")
pct <- package.data[package.data$package == pkg, "percentile"]
pct.label <- paste0(round(pct, 2), "%")
axis(3, at = which(names(crosstab) == pkg), padj = 0.9, col.axis = "red",
  col.ticks = "red", labels = pct.label, cex.axis = 0.8)
axis(4, at = crosstab[pkg], col.axis = "red", col.ticks = "red",
  cex.axis = 0.8, labels = format(crosstab[pkg], big.mark = ","))
points(which(names(crosstab) == pkg), crosstab[pkg], col = "red")
points(which(names(crosstab) == names(crosstab[1])), y.max,
  col = "dodgerblue")
text(which(names(crosstab) == names(crosstab[1])), y.max, pos = 4,
  labels = paste(names(crosstab[1]), "=", format(crosstab[1],
  big.mark = ",")), cex = 0.8, col = "dodgerblue")
text(max(xlim), max(ylim),
  labels = paste("Tot = ", format(sum(crosstab), big.mark = ",")), cex = 0.8,
  col = "dodgerblue", pos = 2)
title(main = paste(pkg, "@", date))
```

These graphs, which are customized to be on the same scale, plot the rank of the download count for _all_ packages downloaded that day (x-axis) against the natural log of those counts (y-axis). It then highlights your package's position in the distribution along with its rank percentile and download count (in red). In the background, the 75th, 50th and 25th percentiles are plotted as dotted gray vertical lines; the package with the most downloads, which in both cases is [`'magrittr'`](https://cran.r-project.org/package=magrittr) (in blue, top left); and the total number of downloads, 5,561,681 and 3,403,969 respectively (in blue, top right).

<br/>

#### note on performance and analytical limits

Unlike `cranlogs::cran_download()`, which benefits from server-side support (i.e., download counts are "pre-computed"), `packageRank()` needs to download the logs from [RStudio](http://cran-logs.rstudio.com/) and compute the ranks of download counts.

This imposes a performance penalty and a limit on analysis. While the performance penalty is mitigated by caching downloaded log files using the [`'memoise'`](https://CRAN.R-project.org/package=memoise) package, the analytic limitation is harder to overcome. Anything beyond a one-day cross-sectional comparison (e.g., rank percentiles over time) is "expensive" because you have to download all the needed log files, each of which can push 50 MB. If you want to compare ranks for a week, you'd have to download 7 log files; if you want to compare ranks for a month, you'd have to download 30 odd log files.

As a proof-of-concept, the plot below compares nominal downloads with rank percentiles for the first week in March:

```{r counts_ranks, fig.align = "center", hugoopts = list(caption = "Figure 10 Count v. Rank Percentiles March 1-7, 2020"), echo = FALSE}

Downloads <- summary(cranDownloads(packages = "cholera", from = "2020-03-01",
  to = "2020-03-07"))$count

Date <- as.Date(c("2020-03-01", "2020-03-02", "2020-03-03", "2020-03-04",
  "2020-03-05", "2020-03-06", "2020-03-07"))

percentiles <- vapply(Date, function(x) {
  dat <- packageRank(package = "cholera", date = x, size.filter = FALSE)
  summary(dat)$percentile
}, numeric(1L))

par(mar = c(5, 4, 4, 4))
plot(Date, Downloads, type = "o", pch = 0, bty = "n", col = "gray")
par(new = TRUE)
plot(Date, percentiles, axes = FALSE, bty = "n", type = "o", pch = 16,
  col= "red", xlab = NA, ylab = NA, lwd = 1.5)
axis(4, at = pretty(range(percentiles)), col.axis = "red", col = "red")
mtext("Rank Percentiles", side = 4, line = 3, col = "red")
abline(h = 50, lty = "dotted", col = "red")
title(main = "Counts v. Rank Percentiles: 'cholera' March 1-7, 2020")
legend(x = "topleft",
       legend = c("Percentile", "Count"),
       col = c("red", "gray"),
       pch = c(15, 0),
       bg = "white",
       cex = 2/3,
       # box.lty = "blank",
       lwd = 1,
       title = NULL)
par(mar = c(5, 4, 4, 2))
```

******

# caveat: positive bias in download counts

Putting aside the elephant in the room package dependencies,[^2] a systematic positive bias affects package download counts. This bias manifests itself in two ways: 1) downloads that are "too small" and 2) an overrepresentation of past versions. The former is, apparently, a kind of software artifact. The latter is, I'll argue, a consequence of efforts to mirror or download CRAN in its entirety. These efforts are what makes both of these "invalid" downloads _especially_ problematic: numerically, they undermine our strategy of counting package downloads by counting log entries; conceptually, they lead us to overestimate interest in a package.

This bias is variable. The greater a package's "true" popularity (i.e., the number of "real" downloads), the lower the bias. Essentially, the bias gets diluted. The greater the number of prior versions, the greater the bias. When all of CRAN is being downloaded, more versions means more package downloads. Fortunately, we can minimize the bias by filtering out "small" downloads, and by filtering out or discounting the presence of prior versions.

### download logs

To understand this bias, you should look at actual download logs. RStudio's logs are [available](http://cran-logs.rstudio.com/). You can also access them using `packageRank::packageLog()`.

Below is the log for 'cholera' for February 2, 2020:

```{r log, eval = FALSE}
packageLog(package = "cholera", date = "2020-02-02")
```
```{r log_code, echo = FALSE, eval = TRUE}
log <- packageLog("cholera", "2020-02-02")
log[, !names(log) %in% c("r_version","r_arch", "r_os")]
```

<br/>

### "small" downloads

Entries 5 through 7 illustrate "small" downloads:

```{r log_small, eval = FALSE, echo = FALSE}
packageLog("cholera", "2020-02-02")[5:7, ]
```
```{r log_small_code, echo = FALSE}
log <- packageLog("cholera", "2020-02-02")
log[5:7, !names(log) %in% c("r_version","r_arch", "r_os")]
```

Notice the differences in size: 4.1 MB, 35 kB and 539 B. On CRAN, the source and binary files of 'cholera' are [4.0 and 4.1 MB \*.tar.gz files](https://cran.r-project.org/src/contrib/Archive/cholera/). In short, the problem with "small" downloads is that we end up overcounting the number of actual downloads.

While I'm unsure about the kB-sized entry (it may be a side effect of caching or an incomplete download), my current understanding is that ~500 B downloads represent [HTTP HEAD requests from lftp](https://github.com/r-hub/cranlogs/issues/45). The earliest example I've found goes back to "2012-10-17" (Note that RStudio's download logs only go back to "2012-10-01".). While these "small" downloads aren't always paired with "complete" downloads like above, their frequency is such that I wonder whether `lftp` or something similar is/was part of the R and/or RStudio.

To get a sense of their frequency, I look back to October 2019. In aggregate, ~500 B downloads account for approximately 2% of the total.[^3] While this seems modest (if 2.5 million downloads could be modest), I'd argue that there's actually something lurking underneath. A closer look reveals that the difference between the total and filtered (without ~500 B entries) counts is greatest on the five Wednesdays.

<!-- ```{r counts_plot, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 7 Total CRAN Downloads With and Without ~500 B Entries"} -->
```{r counts_plot, fig.align = "center", hugoopts = list(alt = "alternative text please make it informative", title = "title of the image", caption = "Figure 11 Total CRAN Downloads With and Without ~500 B Entries"), echo = FALSE}
pt1 <- paste0("0", 1:9)
oct.root <- "2019-10-"
oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

dl.ct <- blog.data$dl.ct
dl.ct2 <- blog.data$dl.ct2

plot(oct, dl.ct, type = "o", col = "red", pch = 15,
  ylim = range(dl.ct, dl.ct2), xlab = "Date", ylab = "Count")
lines(oct, dl.ct2, type = "o", col = "black", pch = 16)
abline(v = oct[id], col = "gray", lty = "dotted")
axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
  col.ticks = "black")
title(main = "Download Counts (Log Entries)")
legend(x = "bottomleft",
       legend = c("all", "filtered"),
       col = c("red", "black"),
       pch = c(15, 16),
       bg = "white",
       cex = 2/3,
       lwd = 1,
       title = NULL)
```

<br/>
To see what's going on, I switch the unit of observation from the number of download counts to the number of unique packages downloaded:

<!-- ```{r packages_plot, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 8 Total Number of Unique Packages Downloaded from CRAN With and Without ~500 B Entries"} -->
```{r packages_plot, fig.align = "center", hugoopts = list(caption = "Figure 12 Total Number of Unique Packages Downloaded from CRAN With and Without ~500 B Entries"), echo = FALSE}
pt1 <- paste0("0", 1:9)
oct.root <- "2019-10-"
oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

pkg.ct <- blog.data$pkg.ct
pkg.ct2 <- blog.data$pkg.ct2

plot(oct, pkg.ct, type = "o", col = "red", pch = 15,
  ylim = range(pkg.ct, pkg.ct2), xlab = "Date", ylab = "Count")
lines(oct, pkg.ct2, type = "o", col = "black", pch = 16, lwd = 2)
abline(v = oct[id], col = "gray", lty = "dotted")
axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
  col.ticks = "black")
title(main = "Packages Downloaded")
legend(x = "bottomleft",
       legend = c("all", "filtered"),
       col = c("red", "black"),
       pch = c(15, 16),
       bg = "white",
       cex = 2/3,
       lwd = 1,
       title = NULL)
```

Doing so, we see that on Wednesdays (+3 days) the total number of unique packages downloaded tops 17,000. This is significant because it exceeds the 15,000+ active packages on CRAN (go [here](https://cran.r-project.org/web/packages/index.html) for the latest count). The only way to hit 17,000+ would be to include some, if not all, of the 2,000+ inactive packages. Based on this, I'd say that on those peak days virtually, if not literally, all packages (active _and_ inactive) on CRAN were downloaded.[^4]

<br/>

### past versions

This actually understates what's going on. It's not just that "all" packages are being downloaded but that all versions of all packages are being download. This is what leads me to believe that there's an overrepresentation of past versions in the package download data.

The problem is not downloads of past versions done for compatibility or research, which one would think would be random and infrequent. Instead, the problem is regular and repeated patterns like:

```{r log_versions, eval = FALSE}
packageLog(packages = "cholera", date = "2019-10-22")[1:8, ]
```
```{r log_full_downloads_code, echo = FALSE}
log <- packageLog("cholera", "2019-10-22")
log[1:8, !names(log) %in% c("r_version","r_arch", "r_os")]
```

<br/>
On this day, eight different versions of 'cholera' were downloaded. A little digging with `packageRank::packageHistory()` reveals that these eight versions were all the existing versions available on that day:
<br/>

```{r packageHistory}
packageHistory("cholera")
```

Showing that "all" versions of all packages are being downloaded is not as easy as showing the effect of "small" downloads. For this post, I'm relying on a random sample of 100 active and 100 inactive packages.

The graph below plots the percent of versions downloaded for each day in October 2019 (IDs 1-100 are _active_ packages; IDs 101-200 are _inactive_ packages). On the five Wednesdays (+ 3 additional days), there's a horizontal line at 100% that indicates that all versions of the packages in the sample were downloaded.[^5]

<br/>

<!-- ```{r versions_plot, fig.align = "center", echo = FALSE, fig.cap = "Figure 9 Percent of Versions Downloaded for 100 Active & 100 Inactive Packages"} -->
```{r versions_plot, fig.align = "center", hugoopts = list(caption = "Figure 13 Percent of Versions Downloaded for 100 Active & 100 Inactive Packages"), echo = FALSE}

cran.pkg_ver <- blog.data$cran.pkg_ver
for (i in seq_along(cran.pkg_ver)) {
  cran.pkg_ver[[i]]$pkg.id <- seq_len(nrow(cran.pkg_ver[[i]]))
}
pkg.dataA <- do.call(rbind, cran.pkg_ver)

archive.pkg_ver <- blog.data$archive.pkg_ver
for (i in seq_along(archive.pkg_ver)) {
  archive.pkg_ver[[i]]$pkg.id <- 100:199
}
pkg.dataB <- do.call(rbind, archive.pkg_ver)

pkg.data <- rbind(pkg.dataA, pkg.dataB)
pkg.data$pct.obs.exp <- 100 * pkg.data$pct.obs.exp

ggplot(data = pkg.data, aes(x = pkg.id, y = pct.obs.exp)) +
  geom_line(col = adjustcolor("red", alpha.f = 0.5), size = 0.5) +
  geom_vline(xintercept = 99.5, col = "black", linetype = "dashed") +
  xlab("Package ID") +
  ylab("Percent") +
  facet_wrap(~ date, ncol = 7) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ggtitle("Percent of Package-Versions Downloaded: Active & Inactive Packages")
```

### solutions

To minimize this bias, we could filter out "small" downloads and past versions. Filtering out 500 B downloads is simple and straightforward (`packageRank()` and `packageLog()` already include this functionality). My [understanding](https://github.com/r-hub/cranlogs/issues/45#issuecomment-553874788) is that there may be plans to do this in 'cranlogs' as well. Filtering out other "small" downloads is more involved. You'd need the size of a "valid" download. Filtering out previous versions is more complicated since you'd not only need to know the current version, you'd probably also want a way to discount rather than simply exclude previous version(s), especially when package update occur.

******

# Significance

Whether you should worry about the bias depends on what you're trying to do. For most, the number of downloads is an estimate of interest in a package and implicitly an estimate of a package's importance and quality (witness all the badges displaying download counts on GitHub repositories). The problem with the bias described above is that it undermines the assumed equivalence between nominal download counts and those estimates: not all downloads are created equal.[^6]

More importantly, it does so in variable, unequal fashion (the rising tide does not lift all boats). The bias is a function of a package's "popularity" (i.e, the number of "valid" downloads) and the number of prior versions. A package with more "real" downloads will be less affected than one with fewer "real" downloads because the bias gets diluted (typically "real" interest is greater than "artificial" interest). A package with more versions will be more greatly affected because, especially if CRAN in its entirety is being downloaded, a package with more versions will record more downloads than one with fewer versions.

<br/>

#### popularity
```{r pkgPlot, echo = FALSE}
pkgPlot <- function(package = "cholera", filter = "size",
  legend.loc = "topleft") {

  if (!filter %in% c("size", "version", "size.version")) {
    stop('Filter must be "size", "version", or "size.version".')
  }

  pt1 <- paste0("0", 1:9)
  oct.root <- "2019-10-"
  oct <- as.Date(c(paste0(oct.root, pt1), paste0(oct.root, 10:31)))
  id <- which(weekdays(oct, abbreviate = TRUE) == "Wed")

  dat <- blog.data[[paste0(package, ".data")]]

  plot(oct, dat$ct, type = "o", col = "red", pch = 15,
    ylim = range(dat[, 1:4]), xlab = "Date", ylab = "Count")
  filter.id <- paste0("ct.", tolower(filter))
  lines(oct, dat[, filter.id], type = "o", col = "black", pch = 16)
  lines(lowess(oct, dat$ct), lty = "dotted", col = "red")
  lines(lowess(oct, dat[, filter.id]), lty = "dotted")
  abline(v = oct[id], col = "gray", lty = "dotted")
  axis(3, at = oct[id], labels = rep("W", length(id)), cex.axis = 0.5,
    col.ticks = "black")

  if (filter == "size") {
    title(main = paste0(package, ": Size"))
    sel <- "ct.size"
  } else if (filter == "version") {
    title(main = paste0(package, ": Version"))
    sel <- "ct.version"
  } else if (filter == "size.version") {
    title(main = paste0(package, ": Size & Version"))
    sel <- "ct.size.version"
  }

  tot <- colSums(dat)
  ptA <- paste0("Downloads: all = ", format(tot["ct"], big.mark = ","),
    "; filtered = ")
  ptB <- paste0("% | ", unique(dat$version.ct), " versions")

  delta.pct <- round(100 * (tot["ct"] - tot[sel]) / tot[sel], 1)
  title(sub = paste0(ptA, format(tot[sel], big.mark = ","), "; %∆ = ",
    format(delta.pct, big.mark = ","), ptB))
  legend(x = legend.loc,
         legend = c("all", "filtered"),
         col = c("red", "black"),
         pch = c(15, 16),
         bg = "white",
         cex = 2/3,
         lwd = 1,
         title = NULL)
}
```
To illustrate the effect of popularity, I compare 'ggplot2' and 'cholera' for October 2019. With one million plus downloads, ~500 B entries inflate the download count for 'ggplot2' by 2%:

<!-- ```{r ggplot2, fig.align = "center", echo = FALSE, fig.cap = "Figure 11 Effect of ~500 B Downloads on Download Counts for a Popular Package"} -->
```{r ggplot2, fig.align = "center", hugoopts = list(caption = "Figure 14 Effect of ~500 B Downloads on Download Counts for a Popular Package"), echo = FALSE}
pkgPlot("ggplot2")
```

With under 400 downloads, ~500 B entries inflate the download count for 'cholera' by 25%:

 <!-- ```{r cholera, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 10 Effect of ~500 B Downloads on Download Counts for an Unpopular Package"} -->
```{r cholera, fig.align = "center", hugoopts = list(caption = "Figure 15 Effect of ~500 B Downloads on Download Counts for an Unpopular Package"), echo = FALSE}
pkgPlot()
```

<br/>

#### number of versions

To illustrate the effect of the number of versions, I compare 'cholera', an active package with 8 versions, and 'VR', an inactive package last updated in 2009, with 92 versions. In both cases, I filter out all downloads except for those of the most recent version.

With 'cholera', past versions inflate the download count by 27%:

<!-- ```{r cholera_version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 13 Effect of the Number of Past Versions on Download Counts for a Package with Few Versions"} -->
```{r cholera_version, fig.align = "center", hugoopts = list(caption = "Figure 16 Effect of the Number of Past Versions on Download Counts for a Package with Few Versions"), echo = FALSE}
pkgPlot(filter = "version")
```

With 'VR', past version inflate the download count by 7,500%:

<!-- ```{r vr_version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 12 Effect of the Number of Past Versions on Download Counts for a Package with Many Versions"} -->
```{r vr_version, fig.align = "center", hugoopts = list(caption = "Figure 17 Effect of the Number of Past Versions on Download Counts for a Package with Many Versions"), echo = FALSE}
pkgPlot("VR", filter = "version")
```

<br/>

#### popularity & versions

To illustrate the joint effect of both ~500 B downloads and previous versions, I again use 'cholera'. Here, we see that the joint effect of both biases inflate the download count by 31%:

<!-- ```{r cholera_size.version, fig.width = 6.5, fig.height = 5, fig.align = "center", echo = FALSE, fig.cap = "Figure 13 Effect of ~500 B Downloads and Number of Past Versions on Download Counts"} -->
```{r cholera_size.version, fig.align = "center", hugoopts = list(caption = "Figure 18 Effect of ~500 B Downloads and Number of Past Versions on Download Counts"), echo = FALSE}
pkgPlot(filter = "size.version")
```

#### aggregate estimate of popularity, versions, and popularity & versions

Even though the bias is pretty mechanical and deterministic, to show that examples above are not idiosyncratic, I conclude with a back-of-the-envelope estimate of the general effect of popularity (unfiltered downloads) and version count (total number of versions) on total bias (the percent change in download counts after filtering out ~500 B download and prior versions).

I reuse the sample of 200 active and inactive packages as the data and fit a linear model using the natural log of the three variables. The hope is that I at least get the signs right and that the bias is negatively related to popularity and positively related to the number of versions.

```{r ols, echo = FALSE}
oct.data <- blog.data$oct.data
smpl <- blog.data$smpl
smpl.histories <- blog.data$smpl.histories
smpl.archive <- blog.data$smpl.archive
smpl.archive.histories <- blog.data$smpl.archive.histories

sample.pkgs <- c(smpl, smpl.archive)
sample.pkgs <- sample.pkgs[sample.pkgs != "hardhat"]

vars <- c("count", "size", "version", "size.version")

p.data <- do.call(rbind, oct.data)
p.data <- lapply(sample.pkgs, function(pkg) {
  colSums(p.data[p.data$package == pkg, vars])
})

histories <- c(smpl.histories[names(smpl.histories) != "hardhat"],
  smpl.archive.histories)

v.ct <- vapply(histories, nrow, integer(1L))

p.data <- data.frame(package = sample.pkgs, do.call(rbind, p.data),
  ver.ct = v.ct, stringsAsFactors = FALSE)

row.names(p.data) <- NULL

p.data$size.bias <- 100 * (p.data$count - p.data$size) / p.data$size
p.data$version.bias <- 100 * (p.data$count - p.data$version) / p.data$version
p.data$size.version.bias <- 100 * (p.data$count - p.data$size.version) /
  p.data$size.version

# p.data$popularity <- p.data$count
p.data$popularity <- p.data$size.version
p.data$versions <- p.data$ver.ct
p.data$bias <- p.data$size.version.bias

ols1 <- lm(log(bias) ~ log(popularity) + log(versions), data = p.data)
ols2 <- lm(log(bias) ~ log(popularity) + log(versions) +
  log(popularity) * log(versions), data = p.data)

# car::avPlots(ols1, layout = c(1, 1), grid = FALSE)
# car::avPlots(ols2, layout = c(1, 1), grid = FALSE)
```

```{r ols_summary, echo = FALSE}
summary(ols2)
```

******

# Conclusions

This post introduces some of the functions and features of [`'packageRank'`](https://cran.r-project.org/package=packageRank). The aim of the package is to put package download counts into context using visualization and nonparametric statistics like the rank percentile. The post also describes a systematic, positive bias that affects download counts and offers some ideas about how to minimize its effect.

The package is a work-in-progress. Suggestions, feature requests and problems can be submitted to the package's repository on [GitHub](https://www.github.com/lindbrook/packageRank/issues/). Additionally, any insights about "small" downloads would be particularly welcome.

I'll conclude on one final bit of data. On February 29, 2020 (a leap day and a Sunday), there was a noticeable decline in traffic to CRAN. Barring some technical issue with [RStudio's logs](http://cran-logs.rstudio.com/), there wasn't anything in the real world that might explain the drop. In the R world however, the day was notable for the release of the source code for R version 3.6.3.

```{r cran_pkgs, fig.align = "center", hugoopts = list(caption = "Figure 19 Leap Day 2020"), echo = FALSE}
plot(cranDownloads(from = "2020-02-25", to = "2020-03-05"), r.version = TRUE)
```

```{r cran_r, fig.align = "center", hugoopts = list(caption = "Figure 20 Leap Day 2020"), echo = FALSE}
plot(cranDownloads("R", from = "2020-02-25", to = "2020-03-05"), r.version = TRUE)
```

In the past I've noticed that website maintenance (renaming files and folders, etc.) sometimes coincides with software updates. So my working hypothesis, which I haven't empirically explored, is that the scripts used to do automated downloading may have been "broken" by changes on CRAN. If so, might this be a better estimate of the actual level of interest in R and its packages?

******

# Notes

[^1]: Similar but limited functionality is available for Bioconductor packages using `bioconductorDownloads()` and `bioconductorRank()`.
[^2]: _Arguably_, package dependencies are a source of inflated download counts.
[^3]: Interestingly, IP addresses with a "US" top level domain code account for 46% of all downloads and 72% of ~500 B downloads. For details, see `head(packageRank::blog.data$ccode.ct, 5)`. "filtered" records download counts without ~500 B entries; "delta" is the arithmetic difference between "unfiltered" and "filtered".
[^4]: The slight upward trend in the peaks probably reflects the addition of new packages during the month.
[^5]: On 22 October 2019, there were two exceptions among inactive packages, 'UScensus2000blkgrp' and 'msDilution', which had zero downloads.
[^6]: The [`'adjustedcranlogs'`](https://cran.r-project.org/package=adjustedcranlogs) package also appears to be concerned with the inflation of package download counts. But its source of inflation are package updates. Based upon my reading of the source code and documentation, I _think_ that its objective is to estimate the number of new users (new package installations) by subtracting the number existing users (installation of package updates) from the total downloads. While this is interesting information, from the perspective of [`'packageRank'`](https://cran.r-project.org/package=packageRank) this is not a bug but a feature. Interest in a package is defined by both new and existing users.
So download spikes are revelatory not problematic. This is why plot.cranDownloads() include `package.version` and `r.version` arguments to annotate graphs with the the release of new package versions and new versions of R.
